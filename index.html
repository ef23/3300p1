<html>

<head>
<title>Trump Twitter Analysis</title>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/topojson.v2.min.js"></script>
<link href="https://fonts.googleapis.com/css?family=Share+Tech+Mono" rel="stylesheet">

<style>
h1 { font-family: 'Share Tech Mono', monospace; font-size: 40px; color: rgb(8,160,233); text-align:center; padding-top: 50px;}
body { font-family: 'Helvetica Neue', 'Arial', sans-serif; background-color:rgb(232,245,253);}
#container {margin: auto;}
svg{display:block;margin:auto;border: solid #ccc 1px; }
</style>

</head>
<body>
<h1 > Trump's Twitter: Analysis of a Stable Genius </h1>
<div id="container">
<script>
/** Regex for grabbing media stuff or other points of interest */
/** generates the regex that requires ALL words to be matched */
function generateRegex(str){
  return "(?=.*" + str + ")"
}

function fakenewsReg(str) {
  return "(?=.*(fake news|fakenews))" + generateRegex(str)
}
var keywords = [fakenewsReg("cnn"), fakenewsReg("fox"), "^(?!.*fake news).*fox.*$", fakenewsReg("(nytimes|new york times)"), fakenewsReg("washington post"), fakenewsReg("(nbc|msnbc)"), "(dems|democrats|dnc)","fbi", "russia", "immigration", "cnn", "(nbc|msnbc)", "(washington post|washingtonpost)", "(nytimes|new york times)", "obama", "fox"]
var titles = ["CNN and Fake News", "FOX and Fake News", "FOX without Fake News", "New York Times and Fake News", "Washington Post and Fake News", "NBC and Fake News", "Democrats", "FBI", "Russia", "Immigration", "CNN", "nbc", "wapo", "nyt", "Obama", "fox"]

var media = ["cnn", "nbc", "msnbc", "washington post", "washingtonpost", "wapo", "nytimes", "new york times", "fox", "media", "press", "fake news", "fakenews", "news", "journal", "reporting"]

/** The code for reading and formatting data */

var width = 1000;
var height = 500;
var padding = 50;
var paddingSides = 100;
var paddingBottom = 150

var vis = d3.select("#container")
vis.append("svg")
.attr("width", width)
.attr("height", height);

var svg = d3.selectAll("svg")

var rawData;
var dict = {};
var sortedCounts = [];
var beforeElectionCount = 0;
var afterElectionCount = 0;
var mediaCount = 0;
var notMediaCount = 0;

/** The X-Axis code for scale and axis */

var mindate = new Date(2015, 5, 15),
    maxdate = new Date(2018, 2, 1)

var xScale = d3.scaleTime()
    .domain([mindate, maxdate])
    .range([paddingSides, width - paddingSides]);

var xAxis = d3.axisBottom(xScale);
  svg.append("g")
  .attr("class", "xAxis")
  .attr("transform", "translate(0," + (height - paddingBottom) + ")")
  .call(xAxis
    .tickFormat(d3.timeFormat('%b'))
    .tickSize(0))
  .selectAll("text").remove()

/** The Y-Axis code for scale and axis */

var midnight = new Date();
midnight.setHours(0, 0, 0, 0);
midnight = midnight.getTime();
var dayInMill = 86400000

var yScale = d3.scaleTime()
  .domain([midnight, midnight + dayInMill - 1])
  .nice(d3.timeDay, 1)
  .rangeRound([padding, height - paddingBottom]);

var yAxis = d3.axisLeft(yScale);
  svg.append("g")
  .attr("class", "yAxis")
  .attr("transform", "translate(" + paddingSides + ", 0)")
  .call(yAxis
    .tickFormat(d3.timeFormat('%H:%M'))
    .tickSize(0)
    .tickPadding(8))

var campaignStartDay = new Date(2015, 5, 15)
var electionDay = new Date(2016, 10, 8)
var inaugrationDay = new Date(2017, 0, 21);
var y2016 = new Date(2016, 0, 1);
var y2017 = new Date(2017, 0, 1);
var y2018 = new Date(2018, 0, 1);
var oct19 = new Date(2016, 9, 19)

function drawLines(svg, height, paddingBottom, xScale, scale) {
  var importantDates = [inaugrationDay, electionDay, campaignStartDay, y2016, y2017, y2018]
  var names = ["Inaugaration Day ", "2016 Pres Election", "Campaign Begins", "2016", "2017", "2018"]

  importantDates.forEach(function(d, i){
    var isNotYear = isNaN(names[i]);

    svg.append("line")
    .attr("stroke-width", 2)
    .attr("stroke", isNotYear ? "grey" : "black")
    .attr("x1", xScale(d))
    .attr("x2", xScale(d))
    .attr("y1", height - paddingBottom)
    .attr("y2", isNotYear ? padding : height - paddingBottom + 10)

    svg.append("text")
    .attr("x", xScale(d))
    .attr("y", height - paddingBottom)
    .attr("font-size", (isNotYear ? 14 : 20) * scale)
    .text(names[i])
    .attr("transform", "rotate(-" + (isNotYear ? 90 : 45) + "," + + xScale(d) + "," + (height - paddingBottom) + ")translate(" + (isNotYear ? -125.5 : -60)*scale + "," + (isNotYear ? 2.5 : 15)*scale +  ")");

  })
}

function drawCircles(svgV, xScale, yScale, data, scale, isSmall){
  data.forEach(function(d){
    //if (!d.is_media && !isSmall) return
    var opacity = 0.4;
    var color = "rgb(208, 211, 212)"
    color = d.is_media ? "rgb(40, 116, 166)" : color
		opacity = d.is_media ? 0.6 : opacity

    svgV.append("circle")
    .attr("r", 3*scale)
    .attr("opacity", opacity)
    .attr("fill", color)
    .attr("cx", xScale(d.created_at))
    .attr("cy", yScale(getTime(d.created_at)))

  })
}

function getTime(date){
   return midnight +
          (date.getHours() * 60 * 60 * 1000) +
          (date.getMinutes() * 60 * 1000) +
          (date.getSeconds() * 1000);
}

d3.json("data.json", callback);

var mediaData = '[';
var testCount = 0;

function callback(data) {
  rawData = data;
  // fix date
  rawData.forEach(function(d, i) {
    var date = d.created_at;
    d.created_at = new Date(date);
    d.is_media = false;
    //TODO
    for (var i = 0; i < media.length; i++) {
      var keyword = media[i];
			lowercased_text = d.text.toLowerCase();
      if(lowercased_text.includes(keyword)){ 
			//new RegExp(keyword).test(lowercased_text)
        d.is_media = true;
				mediaData += JSON.stringify(d) + ', ';
				testCount++;
        break;
      }
    }

    if (d.created_at < new Date(2016, 10, 8)) {
      beforeElectionCount++;
    } else {
      afterElectionCount++;
    }
		
		if (d.is_media == true) { 
			mediaCount++;
		} else {
			notMediaCount++;
		}
  })

  drawCircles(svg, xScale, yScale, rawData, 1, false);
  drawLines(svg, height, paddingBottom, xScale, 1);
  createSmallGraphs();
}
/******************************** END GRAPH 1 ****************************/
</script>
<script>
/********************************** GRAPH 2 ******************************/
// draw SVG set-up
var width = 1000;
var height = 500;
var padding = 50;
var paddingSides = 100;
var paddingBottom = 150;

var graph2 = d3.select("#container");
graph2.append("svg")
.attr("id","#graph2")
.attr("width", width)
.attr("height", height);

var svg2 = d3.select("#graph2");
svg2.append("text")
.text("TEST")
.attr("text-anchor", "middle");

/******************************** END GRAPH 2 ****************************/
/********************************** GRAPH 3 ******************************/


/******************************** END GRAPH 3 ****************************/
/********************************** GRAPH 4 ******************************/



/******************************** END GRAPH 4 ****************************/
function createSmallGraphs(){
  var lowercased = rawData.map(function(d){
    d.text = d.text.toLowerCase()
    return d;
  })
  var filtered = []
  for (var i = 0; i < keywords.length; i++) {
    var regex = new RegExp(keywords[i]);
    var filter = lowercased.filter(function(d) {
      return regex.test(d.text)
    })
    var before = 0;
    var after = 0;
    filtered.concat(filter)
    // filtered.push([keywords[i], before*1.0/beforeElectionCount, after*1.0/afterElectionCount])
  }
  console.log(filtered)
  generateGraph(filtered)
}

function generateGraph(arr){
  var lwidth = 950
  var lheight = 475
  var lpadding = 25;
  var lpaddingSides = 50;
  var lpaddingBottom = 100

  arr.forEach(function(data, i) {
    var body = d3.select("body")
    body.append("svg")
    .attr("id", "svg" + i)
    .attr("width", lwidth)
    .attr("height", lheight);

    var svgLoop = d3.select("#svg" + i)

    var xLoopScale = d3.scaleTime()
        .domain([mindate, maxdate])
        .range([lpaddingSides, lwidth - lpaddingSides]);

    var xLoopAxis = d3.axisBottom(xLoopScale);
      svgLoop.append("g")
      .attr("class", "xLoopAxis")
      .attr("transform", "translate(0," + (lheight - lpaddingBottom) + ")")
      .call(xLoopAxis
        .tickFormat(d3.timeFormat('%b'))
        .tickSize(0))
      .selectAll("text").remove()

    var yLoopScale = d3.scaleTime()
      .domain([midnight, midnight + dayInMill - 1])
      .nice(d3.timeDay, 1)
      .rangeRound([lpadding, lheight - lpaddingBottom]);

    var yLoopAxis = d3.axisLeft(yLoopScale);
      svgLoop.append("g")
      .attr("class", "yLoopAxis")
      .attr("transform", "translate(" + lpaddingSides + ", 0)")
      .call(yLoopAxis
        .tickFormat(d3.timeFormat('%H:%M'))
        .tickSize(0)
        .tickPadding(8))
    drawCircles(svgLoop, xLoopScale, yLoopScale, data, .6, true);
    drawLines(svgLoop, lheight, lpaddingBottom, xLoopScale, .5);
    svgLoop.append("text")
    .attr("text-anchor", "middle")
    .attr("x", lwidth/2)
    .attr("y", 10)
    .text(titles[i]);
  })

}

</script>
</div>
</body>
</html>
